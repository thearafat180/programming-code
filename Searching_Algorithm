#include <bits/stdc++.h>
using namespace std;


// Iterative : Time Complexity: O(logn) & Space Complexity : O(1)

// int main(){
//     vector<int> vec={-5,-4,-3,-2,-1,0,-1,2,3,4,5};
//     int target = 0;
//     int start = 0, end = vec.size()-1;
//     while(start<=end){
//         int mid = start + (end-start)/2;   // mid = (start+end)/2 is also right. But We won't use it because, when both start and end will INT_MAX, then it will overflow.
//         if(vec[mid]>target) end = mid-1;
//         else if(vec[mid]<target) start = mid+1;
//         else{
//             cout << mid << endl;
//             break;
//         }
//     return 0;
//     }
// }


// Linear Search Algorithm : Time Complexity : O(n) & Space Complexity : 

// int main(){
//     vector<int> vec={-5,-4,-3,-2,-1,0,-1,2,3,4,5};
//     int target = 0;
//     for(int i=0;i<vec.size();i++){
//         if(vec[i]==target) cout << i << endl;
//     }
//     return 0;
// }


// Recxursive Actions : Time Complexity : O(logn)   &   Space Complexity : O(logn)

// int binarySearch(vector<int> vec, int start, int end, int target){
//     if(start<=end){
//         int mid = start +(end-start)/2;
//         if(vec[mid]>target) return binarySearch(vec,start,mid-1,target);
//         else if( vec[mid]<target) return binarySearch(vec,mid+1,end,target);
//         else return mid;
//     }
//     return -1;
// }

// int main(){
//     vector<int> vec={-5,-4,-3,-2,-1,0,-1,2,3,4,5};
//     int target = 0;
//     int start = 0, end = vec.size()-1;
//     cout << binarySearch(vec,start,end,target);
//     return 0;
// }
